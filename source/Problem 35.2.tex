\documentclass[a4paper,12pt]{article}

\usepackage[left=2cm,right=2cm,
top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{cmap}					% поиск в PDF
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста

\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[block]{\color{blue}\Medium\bfseries\filcenter}{}{1em}{}
\usepackage{natbib}
\usepackage{esvect}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage[russian]{babel}

\begin{document}

\section{Problem 35.2}

Очевидно, что решение с динамическим программированием не подходит, так как $n = 10^{100}$, даже для хранения этого числа нужна длинная арифметика.

Будем называть колонкой $m$ последовательных плиток. Весь узор строится из $n$ таких колонок.

Две колонки "сочетаются" , если их можно поставить в узоре рядом.

Будем называть маской колонки число, в котором в бите с номером $i$ стоит $1$, если плитка с этим номером в колонке черная и $0$ иначе.

Сделаем матрицу $2^m \times 2^m$, в которой в $i, j$ будет $1$, если колонки с масками $i, j$ "сочетаются" и $0$ иначе.

Эта матрица описывает рекурентный переход, аналогичный тому, который был бы написан в решении с динамическим программированием. 

Если эту матрицу возвести в степень $n$ и умножить справа на матрицу $A$ размера $2^m \times 2^m$, в которой первый столбец состоит из единиц, а остальные элементы - нули, а затем просуммировать элементы этой матрицы, будет получен ответ.

Возводить матрицу в степень можно с помощью бинарного возведения в степень, так что сложность полученого решения - $O(log_2(n)*(2^m*2^m)^3)=O(log_2(n)*2^{6m})$

\end{document}
