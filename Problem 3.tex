\documentclass[a4paper,12pt]{article}

\usepackage[left=2cm,right=2cm,
top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{cmap}					% поиск в PDF
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста

\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[block]{\color{blue}\Medium\bfseries\filcenter}{}{1em}{}
\usepackage{natbib}
\usepackage{esvect}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage[russian]{babel}

\begin{document}

\section{Problem 3}

Для каждой возможной позиции ферзя будем хранить список клеток, которые у него под боем.

На самом деле, это список клеток удобно хранить одним числом - маской, в которой в бите с номером $m * i + j$ единица, если эта клетка под боем. Таким образом, чтобы определить какие клетки находятся под боем у нескольких ферзей, достаточно найти побитовое ИЛИ у соответствующих масок, а чтобы определить все ли поле под боем - сравнить полученное число(маску) с $2^{n*m} - 1$.

Самое простое решение - просто перебирать маску с позициями ферзей, брать побитовое ИЛИ у соответствующих масок, которые отображают клетки под боем и сравнивать это число с $2^{n*m} - 1$. Это работает за $2^{n*m}*n*m$ операций, что очевидно слишком много.

Есть способ сильно уменьшить количество перебираемых комбинаций ферзей. будем расставлять ферзей рекурсивно, поддерживая в рекурсии маску поля, которое под боем. Будем в этой маске находить первую позицию, которая еще не под боем, а затем перебирать позиции, куда можно поставить ферзя, чтобы эта позиция стала под боем. Таким образом, мы никогда не будет проверять такую расстановку ферзей, что из нее можно убрать какого-то ферзя, чтобы все поле по-прежнему было под боем.

\end{document}
