\documentclass[a4paper,12pt]{article}

\usepackage[left=2cm,right=2cm,
top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{cmap}					% поиск в PDF
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста

\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[block]{\color{blue}\Medium\bfseries\filcenter}{}{1em}{}
\usepackage{natbib}
\usepackage{esvect}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage[russian]{babel}

\begin{document}

\section{Доминошки}

Каждую доминошку будем хранить как баланс $a-b$.

Можно решать обычную задачу о рюкзаке и получить сложность $O(n^2)$.

Будем хранить в $dp[i]$ минимальное кол-во доминошек, которые нужно повернуть, чтобы получить баланс $i$. Идея в том, что вместо того, чтобы обновлять весь этот массив dp для каждой доминошки отдельно, будем обновлять его атомарно для всех доминошек с балансом $k$. Т.e. за одну такую операцию мы будем обновлять массив $dp$ сразу всеми доминошками с одинаковым балансом. 

Для каждого баланса $i$ мы будем решать какое оптимальное кол-во доминошек с балансом $k$ следует взять, чтобы обновить $dp[i]$. Т.e. $dp[i]=min\{dp[i-k*t] + t\}$, где $k$ - баланс доминошки, а $t$ - количество доминошек с балансом $k$, которые мы поворачиваем. Для того, чтобы быстро находить этот минимум, можно поддерживать окно очередью на минимум.

Сложность такого решения составляет $O(n*k)$, где $n$ - количество доминошек, а $k$ - максимальный баланс.

\end{document}
